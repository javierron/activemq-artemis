<?xml version="1.0" encoding="UTF-8"?>
<!-- ============================================================================= -->
<!-- Licensed to the Apache Software Foundation (ASF) under one or more            -->
<!-- contributor license agreements. See the NOTICE file distributed with          -->
<!-- this work for additional information regarding copyright ownership.           -->
<!-- The ASF licenses this file to You under the Apache License, Version 2.0       -->
<!-- (the "License"); you may not use this file except in compliance with          -->
<!-- the License. You may obtain a copy of the License at                          -->
<!--                                                                               -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                                -->
<!--                                                                               -->
<!-- Unless required by applicable law or agreed to in writing, software           -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,             -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.      -->
<!-- See the License for the specific language governing permissions and           -->
<!-- limitations under the License.                                                -->
<!-- ============================================================================= -->

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "ActiveMQ_User_Manual.ent">
%BOOK_ENTITIES;
]>
<chapter id="using-jms">
    <title>Using JMS</title>
    <para>Although ActiveMQ provides a JMS agnostic messaging API, many users will be more
        comfortable using JMS.</para>
    <para>JMS is a very popular API standard for messaging, and most messaging systems provide a JMS
        API. If you are completely new to JMS we suggest you follow the<ulink
            url="http://docs.oracle.com/javaee/1.3/jms/tutorial"> Sun
            JMS tutorial</ulink> - a full JMS tutorial is out of scope for this guide.</para>
    <para>ActiveMQ also ships with a wide range of examples, many of which demonstrate JMS API usage.
        A good place to start would be to play around with the simple JMS Queue and Topic example,
        but we also provide examples for many other parts of the JMS API. A full description of the
        examples is available in <xref linkend="examples"/>.</para>
    <para>In this section we'll go through the main steps in configuring the server for JMS and
        creating a simple JMS program. We'll also show how to configure and use JNDI, and also how
        to use JMS with ActiveMQ without using any JNDI.</para>
    <section>
        <title>A simple ordering system</title>
        <para>For this chapter we're going to use a very simple ordering system as our example. It is
            a somewhat contrived example because of its extreme simplicity, but it serves to
            demonstrate the very basics of setting up and using JMS.</para>
        <para>We will have a single JMS Queue called <literal>OrderQueue</literal>, and we will have
            a single <literal>MessageProducer</literal> sending an order message to the queue and a
            single <literal>MessageConsumer</literal> consuming the order message from the
            queue.</para>
        <para>The queue will be a <literal>durable</literal> queue, i.e. it will survive a server
            restart or crash. We also want to pre-deploy the queue, i.e. specify the queue in the
            server JMS configuration so it is created automatically without us having to explicitly
            create it from the client.</para>
    </section>
    <section id="using-jms.jndi.configuration">
        <title>JNDI Configuration</title>
        <para>The JMS specification establishes the convention that <emphasis>administered
            objects</emphasis> (i.e. JMS queue, topic and connection factory instances) are made
            available via the JNDI API.  Brokers are free to implement JNDI as they see fit assuming
            the implementation fits the API. ActiveMQ does not have a JNDI server. Rather, it uses a
            client-side JNDI implementation that relies on special properties set in the environment
            to construct the appropriate JMS objects. In other words, no objects are stored in JNDI
            on the ActiveMQ server. There are simply instantiated on the client based on the provided
            configuration. Let's look at the different kinds of administered objects and how to configure
            them.</para>
        <note>
            <para>The following configuration properties <emphasis>are strictly required when ActiveMQ
                is running in stand-alone mode</emphasis>. When ActiveMQ is integrated to an application
                server (e.g. Wildfly) the application server itself will almost certainly provide a JNDI
                client with its own properties.</para>
        </note>
        <section>
            <title>ConnectionFactory JNDI</title>
            <para>A JMS connection factory is used by the client to make connections to the server.
                It knows the location of the server it is connecting to, as well as many other
                configuration parameters.</para>
            <para>By default, a <literal>javax.naming.Context</literal> instance created using the
                <literal>org.apache.activemq.jndi.ActiveMQInitialContextFactory</literal> will automatically
                have the following connection factories available for lookup:</para>
            <itemizedlist>
                <listitem>
                    <para><literal>ConnectionFactory</literal></para>
                </listitem>
                <listitem>
                    <para><literal>XAConnectionFactory</literal></para>
                </listitem>
                <listitem>
                    <para><literal>QueueConnectionFactory</literal></para>
                </listitem>
                <listitem>
                    <para><literal>TopicConnectionFactory</literal></para>
                </listitem>
            </itemizedlist>
            <para>Here's a simple example of the JNDI context environment for a client looking up a connection factory
                to access an <emphasis>embedded</emphasis> instance of ActiveMQ:</para>
            <programlisting>
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory</programlisting>
            <para>It's really as simple as that. As noted previously, any JNDI context created with the
                <literal>ActiveMQInitialContextFactory</literal> will have a set of default connection factories
                available. Therefore, only the <literal>java.naming.factory.initial</literal> property is required
                to access an embedded broker.</para>
            <para>In certain situations there could be multiple server instances running within a particular JVM. In
                that situation each server would typically have an InVM acceptor with a unique server-ID. A client
                using JMS and JNDI can account for this by specifying a
                <literal>javax.naming.Context.PROVIDER_URL</literal> (<literal>String</literal> value of
                "java.naming.provider.url") in the JNDI environment like <literal>vm://2</literal> where
                <literal>2</literal> is the server-ID for acceptor.</para>
            <para>Here is a list of all the supported URL schemes:</para>
            <itemizedlist>
                <listitem><para><literal>vm</literal></para></listitem>
                <listitem><para><literal>tcp</literal></para></listitem>
                <listitem><para><literal>udp</literal></para></listitem>
                <listitem><para><literal>jgroups</literal></para></listitem>
            </itemizedlist>
            <para>Most clients won't be connecting to an embedded broker. Clients will most commonly connect
                across a network a remote broker. In that case the client can use the
                <literal>javax.naming.Context.PROVIDER_URL</literal> (<literal>String</literal> value of
                "java.naming.provider.url") in the JNDI environment to specify where to connect. Here's a simple
                example of a client configuring a connection factory to connect to a remote broker running on
                myhost:5445:</para>
            <programlisting>
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://myhost:5445</programlisting>
            <para>In the example above the client is using the <literal>tcp</literal> scheme for the provider URL.
                A client may also specify multiple comma-delimited host:port combinations in the URL (e.g.
                <literal>tcp://remote-host1:5445,remote-host2:5445</literal>). Whether there is one or many
                host:port combinations in the URL they are treated as the <emphasis>initial connector(s)</emphasis>
                for the underlying connection.</para>
            <para>The <literal>udp</literal> scheme is also supported which should use an host:port combination that
                matches the <literal>group-address</literal> and <literal>group-port</literal> from the corresponding
                <literal>broadcast-group</literal> configured on the ActiveMQ server(s).</para>
            <para>Each scheme has a specific set of properties which can be set using the traditional URL query string
                format (e.g. <literal>scheme://host:port?key1=value1&amp;key2=value2</literal>) to customize the underlying
                transport mechanism. For example, if a client wanted to connect to a remote server using TCP and SSL
                it would use a <literal>Context.PROVIDER_URL</literal> of
                <literal>tcp://remote-host:5445?ssl-enabled=true</literal>.</para>
            <para>All the properties available for the <literal>tcp</literal> scheme are described in
                <link linkend="configuring-transports.netty">the documentation regarding the Netty transport</link>.</para>
            <para>The <literal>udp</literal> scheme supports 4 properties:</para>
            <itemizedlist>
                <listitem>
                    <para><literal>local-address</literal> - If you are running with multiple network interfaces on the same
                        machine, you may want to specify that the discovery group listens only only a specific interface. To
                        do this you can specify the interface address with this parameter.</para>
                </listitem>
                <listitem>
                    <para><literal>local-port</literal> - If you want to specify a local port to which the datagram socket is
                        bound you can specify it here. Normally you would just use the default value of -1 which signifies
                        that an anonymous port should be used. This parameter is always specified in conjunction with
                        <literal>local-address</literal>.</para>
                </listitem>
                <listitem>
                    <para><literal>refresh-timeout</literal> - This is the period the discovery group waits after receiving
                        the last broadcast from a particular server before removing that servers connector pair entry from its
                        list. You would normally set this to a value significantly higher than the broadcast-period on the
                        broadcast group otherwise servers might intermittently disappear from the list even though they are
                        still broadcasting due to slight differences in timing. This parameter is optional, the default value
                        is 10000 milliseconds (10 seconds).</para>
                </listitem>
                <listitem>
                    <para><literal>discovery-initial-wait-timeout</literal> -  If the connection factory is used immediately
                        after creation then it may not have had enough time to received broadcasts from all the nodes in the
                        cluster. On first usage, the connection factory will make sure it waits this long since creation
                        before creating the first connection. The default value for this parameter is 10000 milliseconds.</para>
                </listitem>
            </itemizedlist>
            <para>Lastly, the <literal>jgroups</literal> scheme is supported which provides an alternative to the
                <literal>udp</literal> scheme for server discovery. The URL pattern is as follows
                <literal>jgroups://&lt;jgroups-xml-conf-filename></literal> where
                <literal>&lt;jgroups-xml-conf-filename></literal> refers to an XML file on the classpath that contains
                the JGroups configuration.</para>
            <para>The <literal>refresh-timeout</literal> and <literal>discovery-initial-wait-timeout</literal> properties
                are supported just like with <literal>udp</literal>.</para>
            <para>Although a <literal>javax.naming.Context</literal> instance created using the
                <literal>org.apache.activemq.jndi.ActiveMQInitialContextFactory</literal> will automatically
                have some connection factories present, it is possible for a client to specify its own connection
                factories. This is done using the
                <literal>org.apache.activemq.jndi.ActiveMQInitialContextFactory.CONNECTION_FACTORY_NAMES</literal>
                property (String value of "connectionFactoryNames"). The value for this property is a comma delimited
                String of all the connection factories the client wishes to create. For example:</para>
            <programlisting>
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://localhost:5445
connectionFactoryNames=myConnectionFactory</programlisting>
            <para>In this example, the client is creating a connection factory named "myConnectionFactory." This
                replaces all the default connection factories so that only the "myConnectionFactory" connection factory
                is available to the client.</para>
            <para>Aside from the underlying transport, the underlying connection factory implementation can also be
                configured using special properties. To configure a particular connection factory the client would
                follow this pattern for the property name to set in the environment:
                <literal>connection.&lt;connection-factory-name>.&lt;property-name></literal>. For example, if the
                client wanted to customize the default connection factory "ConnectionFactory" to support
                high-availability then it would do this:</para>
            <programlisting>
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://myhost:5445
connection.ConnectionFactory.ha=true</programlisting>
            <para>Any property available on the underlying
                <literal>org.apache.activemq.jms.client.ActiveMQConnectionFactory</literal> can be set this way in
                addition to the <literal>ha</literal> (boolean) and <literal>type</literal> (String) properties. Here
                are the different options for the <literal>type</literal>:</para>
            <table frame="topbot" id="using-jms.table.configure.factory.types">
                <title>Configuration for Connection Factory Types</title>
                <tgroup cols="3">
                    <colspec colname="cftype" colnum="1"/>
                    <colspec colname="interface" colnum="2"/>
                    <thead>
                        <row>
                            <entry>type</entry>
                            <entry>interface</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>CF (default)</entry>
                            <entry>javax.jms.ConnectionFactory</entry>
                        </row>
                        <row>
                            <entry>XA_CF</entry>
                            <entry>javax.jms.XAConnectionFactory</entry>
                        </row>
                        <row>
                            <entry>QUEUE_CF</entry>
                            <entry>javax.jms.QueueConnectionFactory</entry>
                        </row>
                        <row>
                            <entry>QUEUE_XA_CF</entry>
                            <entry>javax.jms.XAQueueConnectionFactory</entry>
                        </row>
                        <row>
                            <entry>TOPIC_CF</entry>
                            <entry>javax.jms.TopicConnectionFactory</entry>
                        </row>
                        <row>
                            <entry>TOPIC_XA_CF</entry>
                            <entry>javax.jms.XATopicConnectionFactory</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section>
            <title>Destination JNDI</title>
            <para>JMS destinations are also typically looked up via JNDI. As with connection factories, destinations can
                be configured using special properties in the JNDI context environment. The property
                <emphasis>name</emphasis> should follow the pattern: <literal>queue.&lt;jndi-binding></literal> or
                <literal>topic.&lt;jndi-binding></literal>. The property <emphasis>value</emphasis> should be the name
                of the queue hosted by the ActiveMQ server. For example, if the server had a JMS queue configured like
                so:</para>
            <programlisting>
&lt;queue name="OrderQueue"/></programlisting>
            <para>And if the client wanted to bind this queue to "queues/OrderQueue" then the JNDI properties would be
                configured like so:</para>
            <programlisting>
java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory
java.naming.provider.url=tcp://myhost:5445
queue.queues/OrderQueue=OrderQueue</programlisting>
            <para>It is also possible to look-up JMS destinations which haven't been configured explicitly in the JNDI
                context environment. This is possible using <literal>dynamicQueues/</literal> or
                <literal>dynamicTopics/</literal> in the look-up string. For example, if the client wanted to look-up the
                aforementioned "OrderQueue" it could do so simply by using the string "dynamicQueues/OrderQueue". Note,
                the text that follows <literal>dynamicQueues/</literal> or <literal>dynamicTopics/</literal> must
                correspond <emphasis>exactly</emphasis> to the name of the destination on the server.</para>
        </section>
        <section>
            <title>The code</title>
            <para>Here's the code for the example:</para>
            <para>First we'll create a JNDI initial context from which to lookup our JMS objects. If the above
                properties are set in <literal>jndi.properties</literal> and it is on the classpath then any new, empty
                <literal>InitialContext</literal> will be initialized using those properties:</para>
            <programlisting>InitialContext ic = new InitialContext();</programlisting>
            <para>Now we'll look up the connection factory from which we can create connections to myhost:5445:</para>
            <programlisting>ConnectionFactory cf = (ConnectionFactory)ic.lookup("ConnectionFactory");</programlisting>
            <para>And look up the Queue:</para>
            <programlisting>Queue orderQueue = (Queue)ic.lookup("queues/OrderQueue");</programlisting>
            <para>Next we create a JMS connection using the connection factory:</para>
            <programlisting>Connection connection = cf.createConnection();</programlisting>
            <para>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
                mode:</para>
            <programlisting>Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</programlisting>
            <para>We create a MessageProducer that will send orders to the queue:</para>
            <programlisting>MessageProducer producer = session.createProducer(orderQueue);</programlisting>
            <para>And we create a MessageConsumer which will consume orders from the queue:</para>
            <programlisting>MessageConsumer consumer = session.createConsumer(orderQueue);</programlisting>
            <para>We make sure we start the connection, or delivery won't occur on it:</para>
            <programlisting>connection.start();</programlisting>
            <para>We create a simple TextMessage and send it:</para>
            <programlisting>TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</programlisting>
            <para>And we consume the message:</para>
            <programlisting>TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());</programlisting>
            <para>It is as simple as that. For a wide range of working JMS examples please see the
                examples directory in the distribution.</para>
            <warning>
                <para>Please note that JMS connections, sessions, producers and consumers are
                        <emphasis>designed to be re-used</emphasis>.</para>
                <para>It is an anti-pattern to create new connections, sessions, producers and consumers
                    for each message you produce or consume. If you do this, your application will
                    perform very poorly. This is discussed further in the section on performance tuning
                        <xref linkend="perf-tuning"/>.</para>
            </warning>
        </section>
    </section>
    <section>
        <title>Directly instantiating JMS Resources without using JNDI</title>
        <para>Although it is a very common JMS usage pattern to lookup JMS <emphasis>Administered
            Objects</emphasis> (that's JMS Queue, Topic and ConnectionFactory instances) from JNDI,
            in some cases you just think "Why do I need JNDI? Why can't I just instantiate these
            objects directly?"</para>
        <para>With ActiveMQ you can do exactly that. ActiveMQ supports the direct instantiation of JMS
            Queue, Topic and ConnectionFactory instances, so you don't have to use JNDI at
            all.</para>
        <para>For a full working example of direct instantiation please see the JMS examples in
                <xref linkend="examples"/>.</para>
        <para>Here's our simple example, rewritten to not use JNDI at all:</para>
        <para>We create the JMS ConnectionFactory object via the ActiveMQJMSClient Utility class,
            note we need to provide connection parameters and specify which transport we are using,
            for more information on connectors please see <xref linkend="configuring-transports"
            />.</para>
        <programlisting>              
TransportConfiguration transportConfiguration = new TransportConfiguration(NettyConnectorFactory.class.getName());
ConnectionFactory cf = ActiveMQJMSClient.createConnectionFactoryWithoutHA(JMSFactoryType.CF,transportConfiguration);</programlisting>
        <para>We also create the JMS Queue object via the ActiveMQJMSClient Utility class:</para>
        <programlisting>Queue orderQueue = ActiveMQJMSClient.createQueue("OrderQueue");</programlisting>
        <para>Next we create a JMS connection using the connection factory:</para>
        <programlisting>Connection connection = cf.createConnection();</programlisting>
        <para>And we create a non transacted JMS Session, with AUTO_ACKNOWLEDGE acknowledge
            mode:</para>
        <programlisting>Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</programlisting>
        <para>We create a MessageProducer that will send orders to the queue:</para>
        <programlisting>MessageProducer producer = session.createProducer(orderQueue);</programlisting>
        <para>And we create a MessageConsumer which will consume orders from the queue:</para>
        <programlisting>MessageConsumer consumer = session.createConsumer(orderQueue);</programlisting>
        <para>We make sure we start the connection, or delivery won't occur on it:</para>
        <programlisting>connection.start();</programlisting>
        <para>We create a simple TextMessage and send it:</para>
        <programlisting>TextMessage message = session.createTextMessage("This is an order");
producer.send(message);</programlisting>
        <para>And we consume the message:</para>
        <programlisting>TextMessage receivedMessage = (TextMessage)consumer.receive();
System.out.println("Got order: " + receivedMessage.getText());</programlisting>
    </section>
    <section id="using-jms.clientid">
        <title>Setting The Client ID</title>
        <para>This represents the client id for a JMS client and is needed for creating durable
            subscriptions. It is possible to configure this on the connection factory and can be set
            via the <literal>client-id</literal> element. Any connection created by this connection
            factory will have this set as its client id.</para>
    </section>
    <section id="using-jms.dupsokbatchsize">
        <title>Setting The Batch Size for DUPS_OK </title>
        <para>When the JMS acknowledge mode is set to <literal>DUPS_OK</literal> it is possible to
            configure the consumer so that it sends acknowledgements in batches rather that one at a
            time, saving valuable bandwidth. This can be configured via the connection factory via
            the <literal>dups-ok-batch-size</literal> element and is set in bytes. The default is
            1024 * 1024 bytes = 1 MiB.</para>
    </section>
    <section id="using-jms.txbatchsize">
        <title>Setting The Transaction Batch Size</title>
        <para>When receiving messages in a transaction it is possible to configure the consumer to
            send acknowledgements in batches rather than individually saving valuable bandwidth.
            This can be configured on the connection factory via the <literal
                >transaction-batch-size</literal> element and is set in bytes. The default is 1024 *
            1024.</para>
    </section>
</chapter>
